<?php

/**
 * @see       https://github.com/mezzio/mezzio for the canonical source repository
 * @copyright https://github.com/mezzio/mezzio/blob/master/COPYRIGHT.md
 * @license   https://github.com/mezzio/mezzio/blob/master/LICENSE.md New BSD License
 */

namespace MezzioTest\Container;

use Laminas\Diactoros\Response;
use Laminas\Diactoros\Response\EmitterInterface;
use Laminas\Diactoros\ServerRequest;
use Mezzio\Container\ApplicationFactory;
use Mezzio\Router\Route;
use Mezzio\Router\RouteResult;
use Mezzio\Router\RouterInterface;
use MezzioTest\ContainerTrait;
use PHPUnit_Framework_TestCase as TestCase;
use Prophecy\Argument;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * Integration test case for Application instances generated by ApplicationFactory.
 *
 * This test case is to verify that various configuration scenarios provide an
 * application that will behave in specific ways, including:
 *
 * - Given a middleware spec resolving to error middleware, that middleware
 *   will be executed in error conditions.
 * - Given a middleware spec resolving to an error middleware pipeline, that
 *   pipeline will be executed in error conditions.
 */
class ApplicationFactoryIntegrationTest extends TestCase
{
    use ContainerTrait;

    protected $container;

    public function setUp()
    {
        $this->container = $this->mockContainerInterface();
        $this->factory   = new ApplicationFactory();

        $this->router = $this->prophesize(RouterInterface::class);
        $this->emitter = $this->prophesize(EmitterInterface::class);

        $this->injectServiceInContainer($this->container, RouterInterface::class, $this->router->reveal());
        $this->injectServiceInContainer($this->container, EmitterInterface::class, $this->emitter->reveal());
    }

    public function testConfiguredErrorMiddlewarePipeIsExecutedWhenMiddlewareCallsNextWithError()
    {
        $always = function ($request, $response, $next) {
            $response = $next($request, $response);
            return $response->withHeader('X-Always', 'true');
        };

        $routeResultSpy = function ($request, $response, $next) {
            $result = $request->getAttribute(RouteResult::class, false);
            $value = $result ? $result->getMatchedRouteName() : 'not-found';
            return $next($request, $response->withHeader('X-Route-Result', $value));
        };

        $needsAuthentication = function ($request, $response, $next) {
            return $next($request, $response, '401');
        };

        $unauthorized = function ($error, $request, $response, callable $next = null) {
            $this->assertEquals('401', $error);
            $response->getBody()->write('Error middleware called');
            return $response->withStatus(401);
        };

        $finalHandler = function ($request, $response, $err = null) {
            $this->fail('Should not hit final handler, but did');
        };

        $routeResult = $this->prophesize(RouteResult::class);
        $routeResult->isFailure()->willReturn(false);
        $routeResult->getMatchedParams()->willReturn([]);
        $routeResult->getMatchedRouteName()->willReturn('needs-auth');
        $routeResult->getMatchedMiddleware()->willReturn('NeedsAuthentication');
        $this->router->match(Argument::type(ServerRequestInterface::class))->willReturn($routeResult->reveal());

        $this->injectServiceInContainer($this->container, 'Always', $always);
        $this->injectServiceInContainer($this->container, 'RouteResultSpy', $routeResultSpy);
        $this->injectServiceInContainer($this->container, 'NeedsAuthentication', $needsAuthentication);
        $this->injectServiceInContainer($this->container, 'Unauthorized', $unauthorized);
        $this->injectServiceInContainer($this->container, 'Mezzio\FinalHandler', $finalHandler);

        $config = [
            'routes' => [
                'name' => 'needs-auth',
                'path' => '/needs/authentication',
                'middleware' => 'NeedsAuthentication',
                'allowed_methods' => ['GET'],
            ],
            'middleware_pipeline' => [
                'always' => [
                    'middleware' => [
                        'Always',
                    ],
                    'priority' => 10000,
                ],
                'routing' => [
                    'middleware' => [
                        ApplicationFactory::ROUTING_MIDDLEWARE,
                        'RouteResultSpy',
                        ApplicationFactory::DISPATCH_MIDDLEWARE,
                    ],
                    'priority' => 1,
                ],
                'error' => [
                    'middleware' => [
                        'Unauthorized',
                    ],
                    'priority' => -10000,
                    'error' => true,
                ],
            ],
        ];
        $this->injectServiceInContainer($this->container, 'config', $config);

        $app = $this->factory->__invoke($this->container->reveal());

        $request = new ServerRequest([], [], 'http://example.com/needs/authentication', 'GET');
        $response = new Response();

        $response = $app($request, $response);
        $this->assertInstanceOf(ResponseInterface::class, $response);
        $this->assertEquals(401, $response->getStatusCode(), 'Unexpected response');
        $this->assertTrue($response->hasHeader('X-Always'));
        $this->assertEquals('true', $response->getHeaderLine('X-Always'));
        $this->assertTrue($response->hasHeader('X-Route-Result'));
        $this->assertEquals('needs-auth', $response->getHeaderLine('X-Route-Result'));
        $this->assertEquals('Error middleware called', (string) $response->getBody());
    }

    public function testConfiguredErrorMiddlewareIsExecutedWhenMiddlewareCallsNextWithError()
    {
        $always = function ($request, $response, $next) {
            $response = $next($request, $response);
            return $response->withHeader('X-Always', 'true');
        };

        $routeResultSpy = function ($request, $response, $next) {
            $result = $request->getAttribute(RouteResult::class, false);
            $value = $result ? $result->getMatchedRouteName() : 'not-found';
            return $next($request, $response->withHeader('X-Route-Result', $value));
        };

        $needsAuthentication = function ($request, $response, $next) {
            return $next($request, $response, '401');
        };

        $unauthorized = function ($error, $request, $response, callable $next = null) {
            $this->assertEquals('401', $error);
            $response->getBody()->write('Error middleware called');
            return $response->withStatus(401);
        };

        $finalHandler = function ($request, $response, $err = null) {
            $this->fail('Should not hit final handler, but did');
        };

        $routeResult = $this->prophesize(RouteResult::class);
        $routeResult->isFailure()->willReturn(false);
        $routeResult->getMatchedParams()->willReturn([]);
        $routeResult->getMatchedRouteName()->willReturn('needs-auth');
        $routeResult->getMatchedMiddleware()->willReturn('NeedsAuthentication');
        $this->router->match(Argument::type(ServerRequestInterface::class))->willReturn($routeResult->reveal());

        $this->injectServiceInContainer($this->container, 'Always', $always);
        $this->injectServiceInContainer($this->container, 'RouteResultSpy', $routeResultSpy);
        $this->injectServiceInContainer($this->container, 'NeedsAuthentication', $needsAuthentication);
        $this->injectServiceInContainer($this->container, 'Unauthorized', $unauthorized);
        $this->injectServiceInContainer($this->container, 'Mezzio\FinalHandler', $finalHandler);

        $config = [
            'routes' => [
                'name' => 'needs-auth',
                'path' => '/needs/authentication',
                'middleware' => 'NeedsAuthentication',
                'allowed_methods' => ['GET'],
            ],
            'middleware_pipeline' => [
                'always' => [
                    'middleware' => [
                        'Always',
                    ],
                    'priority' => 10000,
                ],
                'routing' => [
                    'middleware' => [
                        ApplicationFactory::ROUTING_MIDDLEWARE,
                        'RouteResultSpy',
                        ApplicationFactory::DISPATCH_MIDDLEWARE,
                    ],
                    'priority' => 1,
                ],
                'error' => [
                    'middleware' => 'Unauthorized',
                    'priority' => -10000,
                    'error' => true,
                ],
            ],
        ];
        $this->injectServiceInContainer($this->container, 'config', $config);

        $app = $this->factory->__invoke($this->container->reveal());

        $request = new ServerRequest([], [], 'http://example.com/needs/authentication', 'GET');
        $response = new Response();

        $response = $app($request, $response);
        $this->assertInstanceOf(ResponseInterface::class, $response);
        $this->assertEquals(401, $response->getStatusCode(), 'Unexpected response');
        $this->assertTrue($response->hasHeader('X-Always'));
        $this->assertEquals('true', $response->getHeaderLine('X-Always'));
        $this->assertTrue($response->hasHeader('X-Route-Result'));
        $this->assertEquals('needs-auth', $response->getHeaderLine('X-Route-Result'));
        $this->assertEquals('Error middleware called', (string) $response->getBody());
    }
}
